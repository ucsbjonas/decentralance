// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
import {MarketPlace} from "../src/MarketPlace.sol";
import {Listing} from "../src/Listing.sol";
import "forge-std/Vm.sol";

contract Attacker {

    MarketPlace public marketplace;
    uint256 listing_id;

    constructor(MarketPlace _mp, _listing_id) {
        // not implemented
        marketplace = _mp;
        listing_id = _listing_id;
    }

    
    fallback() external payable {
        marketplace.fufill_current_stage(listing_id);
    }
}

//these tests test the last specification of the track and some reentrancy
contract AttackerTest is Test {
    MarketPlace public marketPlace;
    Listing public new_listing;

    Attacker attacker;

    address contractor = address(0x10);
    address client = address(0x11);

    uint256[] public amounts;
    uint256[] public delivery_dates;

    uint256 listing_id;

    function setUp() public {

        vm.deal(contractor, 100 ether);
        vm.deal(client, 100 ether);

        marketPlace = new MarketPlace();
        attacker = new Attacker();

        amounts.push(1 ether);
        amounts.push(5 ether);
        delivery_dates.push(vm.getBlockTimestamp() + 100);
        delivery_dates.push(vm.getBlockTimestamp() + 250);

        marketPlace.add_contractor(address(contractor));
        marketPlace.add_client(address(client));
    }

    //test the last specification
    // If two contractors accept a listing, there is a choice of contractor when the client calls confirmListing
    function test_same_block() public{
        //create listing
        vm.startBroadcast(client);
        new_listing = new Listing(msg.sender, 
                                amounts,
                                delivery_dates,
                                "a commission for you");
        listing_id = marketPlace.addListing(new_listing);
        vm.stopBroadcast();

        //contractor accepts
        vm.startBroadcast(contractor);
        timestamp_first = vm.getBlockTimestamp();
        marketPlace.acceptListing(listing_id);
        vm.stopBroadcast();

        //another contractor accepts
        address contractor_other = address(0x12);
        vm.startBroadcast(contractor_other);
        timestamp_second = vm.getBlockTimestamp();
        marketPlace.acceptListing(listing_id);
        vm.stopBroadcast();

        //client confirms and selects a contractor to work with
        vm.startBroadcast(client);
        marketPlace.confirmListing(listing_id, address(contractor_other));
        vm.stopBroadcast(contractor);

        assertEq(timestamp_first, timestmp_second, "not same block");
        assertEq(marketPlace.listing_lookup(listing_id).contractor(), address(contractor_other), "wrong contractor");
    }

    //attempt to reenter the contract and call pay_current_stage multiple times
    //the only external call made in MarketPlace.sol functions should be to the contractor (to receive payment)
    function test_reentrancy_payment() public {

        //create listing
        vm.startBroadcast(client);
        new_listing = new Listing(msg.sender, 
                                amounts,
                                delivery_dates,
                                "a commission for you");
        listing_id = marketPlace.addListing(new_listing);
        vm.stopBroadcast();

        //contractor accepts
        vm.startBroadcast(address(attacker));
        marketPlace.acceptListing(listing_id);
        vm.stopBroadcast();

        //client confirms
        vm.startBroadcast(client);
        marketPlace.confirmListing(listing_id, address(attacker));
        vm.stopBroadcast(contractor);


        vm.startBroadcast(address(attacker));
        bool success = marketPlace.fulfill_current_stage(listing_id);
        vm.stopBroadcast();


        //check that multiple stages cannot advanced at once
        vm.startBroadcast(client);
        bool success1 = marketPlace.pay_current_stage{value: 1 ether}(listing_id);
        assertEq(success1, true, "failed to pay current stage");
        assertEq(marketPlace.listing_lookup(listing_id).curr_stage(), 1, "did not move to next stage");
        vm.stopBroadcast();
        
    }

}

